<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>EchoInTrack - Dashboard</title>
    <link rel="icon" type="image/x-icon" href="/templates/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1C1C1C;
            color: white;
        }
.header {
    display: flex;
    justify-content: flex-start; /* Align items to the left by default */
    align-items: center;
    margin-bottom: 20px;
    background: #2A2A2A;
    padding: 15px;
    border-radius: 10px;
    gap: 15px; /* Adds space between buttons */
}

.clock {
    margin-left: auto; /* Pushes the clock to the far right */
    font-size: 1.2em;
    font-weight: bold;
    color: #FFD67A;
}


        .back-button {
            background: #FFD67A;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            color: #1C1C1C;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .back-button:hover {
            background: #FFC04D;
        }
        .stats-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }
        .stat-card {
            background: #2A2A2A;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .requests-container {
            background: #2A2A2A;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        .request-bar {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            transition: transform 0.2s;
        }
        .request-bar:hover {
            transform: scale(1.0);
        }
        .purple { background: purple; }
        .red { background: red; }
        .amber { background: orange; }
        .green { background: green; }
        .request-id {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            margin-right: 10px;
        }
        .chart-container {
            background: #2A2A2A;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            height: 400px;
        }
        .time-remaining {
            margin-left: auto;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }
        .overdue {
            color: #ff4444;
            font-weight: bold;
        }
        .request-actions {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }
        .action-button {
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 0.8em;
            transition: background-color 0.3s;
        }
        .perform-button {
            background: #4CAF50;
            color: white;
        }
        .perform-button:hover {
            background: #45a049;
        }
        .delete-button {
            background: #f44336;
            color: white;
        }
        .delete-button:hover {
            background: #333333;
        }
        .requests-header {
            margin: 20px 0 10px 0;
            padding: 10px;
            background: #4262c9;
            border-radius: 5px;
        }
        .requests-header-green {
            margin: 20px 0 10px 0;
            padding: 10px;
            background: green;
            border-radius: 5px;
        }
        #pendingRequests, #performedRequests, #greenRejectedRequests {
            margin-top: 10px;
        }

        .undo-button {
    background: #005aff;
    color: white;
}

.undo-button:hover {
    background: #FF8C00;
}

 .stats-container {
    display: grid;
    grid-template-columns: repeat(6, 1fr);  /* Changed from 5 to 6 columns */
    gap: 20px;
    margin-bottom: 30px;
}

.stat-card {
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    color: white;
}

.stat-card h3 {
    margin: 0 0 10px 0;
    font-size: 1.1em;
    color: rgba(255, 255, 255, 0.9);
}

.stat-card div {
    font-size: 2em;
    font-weight: bold;
}

.purple-card {
    background: rgba(128, 0, 128, 0.8);
}

.red-card {
    background: rgba(255, 0, 0, 0.8);
}

.amber-card {
    background: rgba(255, 165, 0, 0.8);
}

.green-card {
    background: rgba(0, 128, 0, 0.8);
}

.blue-card {
    background: rgba(0, 122, 255, 0.8);
}

.overdue-card {
    background: rgba(54, 69, 79, 0.8);
}

.stat-card:hover {
    transform: scale(1.02);
    transition: transform 0.2s ease;
}
.show-more-button {
            background: #4a4a4a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 0;
            width: 100%;
            transition: background-color 0.3s;
        }
        .show-more-button:hover {
            background: #666;
        }

    </style>
</head>
<body>
<div class="header">
    <button class="back-button" onclick="window.location.href='/'">Back to Triage</button>
    <button id="logoutBtn" class="back-button">Logout</button>
    <button class="back-button" onclick="window.location.href='/raw'">Raw Data</button>
    <div class="clock" id="clock"></div>
</div>

<div class="stats-container">
    <div class="stat-card overdue-card">
        <h3>⚠️ Overdue</h3>
        <div id="overdue_count">0</div>
    </div>

    <div class="stat-card purple-card">
        <h3>Purple pending scan</h3>
        <div id="purpleCount">0</div>
    </div>

    <div class="stat-card red-card">
        <h3>Red pending scan</h3>
        <div id="redCount">0</div>
    </div>

    <div class="stat-card amber-card">
        <h3>Amber pending scan</h3>
        <div id="amberCount">0</div>
    </div>

    <div class="stat-card green-card">
        <h3>Today's Green</h3>
        <div id="greenCount">0</div>
    </div>

    <div class="stat-card blue-card">
        <h3>Performed Today</h3>
        <div id="performedCount">0</div>
    </div>
</div>

<div class="chart-container">
    <canvas id="dailyChart"></canvas>
</div>

<div class="requests-container">
    <div class="requests-header">
        <h3>Pending</h3>
    </div>
    <div id="pendingRequests"></div>

    <div class="requests-header">
        <h3>Performed</h3>
    </div>
    <div id="performedRequests"></div>
    <button id="showMorePerformed" class="show-more-button" style="display: none;">Show More</button>

    <div class="requests-header-green">
        <h3>Green & Rejected</h3>
    </div>
    <div id="greenRejectedRequests"></div>
    <button id="showMoreGreenRejected" class="show-more-button" style="display: none;">Show More</button>
</div>

<script>
    let dailyChart;
    let allRequests = [];
    let performedDisplayCount = 5;
    let greenRejectedDisplayCount = 5;

function updateClock() {
    // Use Intl.DateTimeFormat for proper time zone handling
    const now = new Date();
    const formatter = new Intl.DateTimeFormat('en-GB', {
        timeZone: 'Europe/London',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        day: '2-digit',
        month: 'short',
        year: 'numeric',
    });

    const parts = formatter.formatToParts(now);
    const time = `${parts.find(p => p.type === 'hour').value}:${parts.find(p => p.type === 'minute').value}:${parts.find(p => p.type === 'second').value}`;
    const date = `${parts.find(p => p.type === 'day').value} ${parts.find(p => p.type === 'month').value.toUpperCase()} ${parts.find(p => p.type === 'year').value}`;

    document.getElementById('clock').textContent = `${time} - ${date}`;
}

// Call the function immediately and set an interval to update
updateClock();
setInterval(updateClock, 1000);


    function formatTimeRemaining(expectedTime) {
        const now = new Date();
        const expected = new Date(expectedTime);
        const diff = expected - now;

        if (diff < 0) return 'Overdue';

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));

        return `${hours}h ${minutes}m remaining`;
    }

function updateDailyChart(stats) {
    fetch('/api/get_daily_overdue')
        .then(response => response.json())
        .then(overdueData => {
            const ctx = document.getElementById('dailyChart').getContext('2d');

            // Get dates and sort chronologically
            const dates = Object.keys(stats).sort((a, b) => new Date(a) - new Date(b));

            // Build processed data
            const processedData = dates.map(date => {
                const dayStats = stats[date] || {};
                return {
                    date: new Date(date),
                    performed: parseInt(dayStats['PERFORMED'] || 0),
                    purple: parseInt(dayStats['PURPLE PATHWAY'] || 0),
                    red: parseInt(dayStats['RED PATHWAY'] || 0),
                    amber: parseInt(dayStats['AMBER PATHWAY'] || 0),
                    green: parseInt((dayStats['GREEN PATHWAY'] || 0) + (dayStats['REJECTED'] || 0)),
                    overdue: parseInt(overdueData[date] || 0)
                };
            });

            // Build datasets
            const datasets = [
                // --- Lines go on the 'yLine' axis (non-stacked) ---
                {
                    label: 'Overdue',
                    data: processedData.map(d => d.overdue),
                    type: 'line',
                    borderColor: '#ff4444',
                    backgroundColor: '#ff4444',
                    borderWidth: 2,
                    pointBackgroundColor: '#ff4444',
                    order: 0,
                    yAxisID: 'yLine'  // <--- put line on non-stacked axis
                },
                {
                    label: 'Performed',
                    data: processedData.map(d => d.performed),
                    type: 'line',
                    borderColor: 'blue',
                    backgroundColor: 'blue',
                    borderWidth: 2,
                    pointBackgroundColor: 'blue',
                    order: 1,
                    yAxisID: 'yLine'  // <--- line on non-stacked axis
                },

                // --- Bars go on the 'y' axis (stacked) ---
                {
                    label: 'Purple',
                    data: processedData.map(d => d.purple),
                    backgroundColor: 'purple',
                    stack: 'barStack',
                    order: 2,
                    yAxisID: 'y'      // <--- bar on stacked axis
                },
                {
                    label: 'Red',
                    data: processedData.map(d => d.red),
                    backgroundColor: 'red',
                    stack: 'barStack',
                    order: 2,
                    yAxisID: 'y'
                },
                {
                    label: 'Amber',
                    data: processedData.map(d => d.amber),
                    backgroundColor: 'orange',
                    stack: 'barStack',
                    order: 2,
                    yAxisID: 'y'
                },
                {
                    label: 'Green & Rejected',
                    data: processedData.map(d => d.green),
                    backgroundColor: 'green',
                    stack: 'barStack',
                    order: 2,
                    yAxisID: 'y'
                }
            ];

            // Compute the largest value across all datasets
            const allValues = processedData.flatMap(d => [
                d.overdue, d.performed, d.purple, d.red, d.amber, d.green
            ]);
            const maxData = Math.max(...allValues);

            // If chart exists, destroy before re-drawing
            if (dailyChart) {
                dailyChart.destroy();
            }

            // Build the chart
            dailyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: processedData.map(d => {
                        // Add 1 day to display date
                        const displayDate = new Date(d.date);
                        displayDate.setDate(displayDate.getDate() + 1);
                        return displayDate.toLocaleDateString('en-GB', {
                            day: '2-digit',
                            month: '2-digit'
                        });
                    }),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Daily Triage Statistics (Last 15 Days)',
                            color: 'white'
                        },
                        legend: {
                            labels: {
                                color: 'white'
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#444' },
                            ticks: { color: 'white' }
                        },

                        // --- 1) "y" axis for stacked bars ---
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            suggestedMax: maxData + 1,  // unify domain
                            grid: { color: '#444' },
                            ticks: {
                                color: 'white',
                                stepSize: 1,
                                callback: value => Math.round(value)
                            },
                            title: {
                                display: true,
                                text: 'Count',
                                color: 'white'
                            }
                        },

                        // --- 2) "yLine" axis for lines, not stacked ---
                        yLine: {
                            stacked: false,
                            beginAtZero: true,
                            suggestedMax: maxData + 1,  // match bar axis top
                            // Hide this axis if you only want one visible
                            display: false,
                            // Keep the grid from overlapping or duplicating
                            grid: { drawOnChartArea: false },
                            ticks: {
                                stepSize: 1  // optional
                            }
                        }
                    }
                }
            });
        });
}


function createRequestBar(req) {
    const bar = document.createElement('div');
    const pathwayType = req.pathway.split(' ')[0].toLowerCase();
    bar.className = `request-bar ${pathwayType}`;
    if (req.pathway === 'GREEN PATHWAY' || req.pathway === 'REJECTED') {
        bar.className = 'request-bar green';
    }

    const requestId = document.createElement('span');
    requestId.className = 'request-id';
    requestId.textContent = `ID: ${req.request_id}`;
    bar.appendChild(requestId);

    const pathwayText = document.createElement('span');
    pathwayText.textContent = req.pathway;
    bar.appendChild(pathwayText);

    const timeInfo = document.createElement('span');
    timeInfo.className = 'time-remaining';

    if (req.status === 'completed') {
        // For performed requests, show completion time with status emoji
        const completionTime = new Date(req.completion_time);
        const expectedTime = new Date(req.expected_time);

        // Always show ✅ for Green Pathway/Rejected entries
        if (req.pathway === 'GREEN PATHWAY' || req.pathway === 'REJECTED') {
            timeInfo.textContent = `${completionTime.toLocaleString('en-GB')} ✅`;
        } else {
            // For other pathways, check if completed on time
            const onTime = completionTime <= expectedTime;
            const statusEmoji = onTime ? '✅' : '⏰';
            timeInfo.textContent = `${completionTime.toLocaleString('en-GB')} ${statusEmoji}`;

            if (!onTime) {
                timeInfo.classList.add('overdue');
            }
        }
    } else if (req.pathway === 'GREEN PATHWAY' || req.pathway === 'REJECTED') {
        // For green & rejected, show request time
        const requestDate = new Date(req.request_time);
        timeInfo.textContent = requestDate.toLocaleString('en-GB');
    } else {
        // For pending requests, show remaining time
        const remainingText = formatTimeRemaining(req.expected_time);
        timeInfo.textContent = remainingText;
        if (remainingText === 'Overdue') {
            timeInfo.classList.add('overdue');
        }
    }
    bar.appendChild(timeInfo);

    const actions = document.createElement('div');
    actions.className = 'request-actions';

    if (req.status !== 'completed') {
        const performButton = document.createElement('button');
        performButton.className = 'action-button perform-button';
        performButton.textContent = 'Perform';
        performButton.onclick = (e) => {
            e.stopPropagation();
            markCompleted(req.id);
        };
        actions.appendChild(performButton);
    } else {
        const undoButton = document.createElement('button');
        undoButton.className = 'action-button undo-button';
        undoButton.textContent = 'Back to Pending';
        undoButton.onclick = (e) => {
            e.stopPropagation();
            undoCompleted(req.id);
        };
        actions.appendChild(undoButton);
    }

    const deleteButton = document.createElement('button');
    deleteButton.className = 'action-button delete-button';
    deleteButton.textContent = 'Delete';
    deleteButton.onclick = (e) => {
        e.stopPropagation();
        deleteRequest(req.id);
    };
    actions.appendChild(deleteButton);

    bar.appendChild(actions);
    return bar;
}

function undoCompleted(id) {
fetch('/api/undo_completed', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ id: id })
})
.then(() => updateDashboard());
}

function updateDashboard() {
        Promise.all([
            fetch('/api/get_requests'),
            fetch('/api/get_daily_stats'),
            fetch('/api/get_today_stats')
        ])
        .then(([requestsResponse, statsResponse, todayStatsResponse]) =>
            Promise.all([requestsResponse.json(), statsResponse.json(), todayStatsResponse.json()])
        )
        .then(([requests, stats, todayStats]) => {
            // Update stats counters
            document.getElementById('purpleCount').textContent = todayStats['PURPLE PATHWAY'] || 0;
            document.getElementById('redCount').textContent = todayStats['RED PATHWAY'] || 0;
            document.getElementById('amberCount').textContent = todayStats['AMBER PATHWAY'] || 0;
            document.getElementById('greenCount').textContent = todayStats['GREEN PATHWAY'] || 0;
            document.getElementById('performedCount').textContent = todayStats['PERFORMED'] || 0;
            document.getElementById('overdue_count').textContent = todayStats['OVERDUE'] || 0;

            allRequests = requests;
            updateRequestLists();
            updateDailyChart(stats);
        });
    }

  function updateRequestLists() {
        const pendingList = document.getElementById('pendingRequests');
        const performedList = document.getElementById('performedRequests');
        const greenRejectedList = document.getElementById('greenRejectedRequests');

        pendingList.innerHTML = '';
        performedList.innerHTML = '';
        greenRejectedList.innerHTML = '';

        const performedRequests = allRequests.filter(req => req.status === 'completed');
        const greenRejectedRequests = allRequests.filter(req =>
            req.pathway === 'GREEN PATHWAY' || req.pathway === 'REJECTED'
        );
        const pendingRequests = allRequests.filter(req =>
            req.status !== 'completed' &&
            req.pathway !== 'GREEN PATHWAY' &&
            req.pathway !== 'REJECTED'
        );

        // Show all pending requests
        pendingRequests.forEach(req => {
            pendingList.appendChild(createRequestBar(req));
        });

        // Show limited performed requests
        performedRequests.slice(0, performedDisplayCount).forEach(req => {
            performedList.appendChild(createRequestBar(req));
        });

        // Show limited green/rejected requests
        greenRejectedRequests.slice(0, greenRejectedDisplayCount).forEach(req => {
            greenRejectedList.appendChild(createRequestBar(req));
        });

        // Update "Show More" buttons visibility
        const showMorePerformed = document.getElementById('showMorePerformed');
        const showMoreGreenRejected = document.getElementById('showMoreGreenRejected');

        showMorePerformed.style.display = performedRequests.length > performedDisplayCount ? 'block' : 'none';
        showMoreGreenRejected.style.display = greenRejectedRequests.length > greenRejectedDisplayCount ? 'block' : 'none';
    }

    // Add event listeners for "Show More" buttons
    document.getElementById('showMorePerformed').addEventListener('click', () => {
        performedDisplayCount += 5;
        updateRequestLists();
    });

    document.getElementById('showMoreGreenRejected').addEventListener('click', () => {
        greenRejectedDisplayCount += 5;
        updateRequestLists();
    });

function formatDate(d) {
    // Use Intl.DateTimeFormat for proper UK time formatting
    return new Intl.DateTimeFormat('en-GB', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric'
    }).format(new Date(d));
}

function formatTime(d) {
    // Use Intl.DateTimeFormat for proper UK time formatting
    return new Intl.DateTimeFormat('en-GB', {
        hour: '2-digit',
        minute: '2-digit',
        hour12: false
    }).format(new Date(d));
}


    function markCompleted(id) {
        fetch('/api/mark_completed', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ id: id })
        })
        .then(() => updateDashboard());
    }

    function deleteRequest(id) {
        fetch('/api/delete_request', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ id: id })
        })
        .then(() => updateDashboard());
    }

async function handleLogout() {
    try {
        const response = await fetch('/logout', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            credentials: 'include' // Include session cookies
        });

        if (response.ok) {
            window.location.href = '/login';
        } else {
            alert('Failed to log out. Please try again.');
        }
    } catch (error) {
        console.error('Error during logout:', error);
        alert('An unexpected error occurred during logout.');
    }
}

// Update all logout button event listeners to use this function
document.addEventListener('DOMContentLoaded', function() {
    const logoutBtn = document.getElementById('logoutBtn');
    if (logoutBtn) {
        logoutBtn.addEventListener('click', handleLogout);
    }

    // Also update the logout buttons in the header sections
    const headerLogoutBtns = document.querySelectorAll('.back-button[onclick*="/logout"]');
    headerLogoutBtns.forEach(btn => {
        btn.removeAttribute('onclick');
        btn.addEventListener('click', handleLogout);
    });
});


    // Initial load
    updateDashboard();
    updateClock();
    // Refresh every 30 seconds
    setInterval(updateDashboard, 30000);
    setInterval(updateClock, 1000);


</script>
</body>
</html>